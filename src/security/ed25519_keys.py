"""Ed25519 key management for agent signing and verification.

Provides per-agent asymmetric key pairs so that:
- Each agent signs messages / audit logs with its *private* key.
- Any party can verify the signature with the agent's *public* key.
- An agent cannot impersonate another agent (private keys are never shared).

Keys are loaded from PEM files generated by ``scripts/setup.sh``
(``keys/<agent>_private.pem`` / ``keys/<agent>_public.pem``), from
environment variables (``<AGENT>_PRIVATE_KEY``), or — as a last-resort
fallback for development — auto-generated in memory.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Optional

import structlog
from cryptography.hazmat.primitives.asymmetric.ed25519 import (
    Ed25519PrivateKey,
    Ed25519PublicKey,
)
from cryptography.hazmat.primitives import serialization

logger = structlog.get_logger(__name__)


class Ed25519KeyPair:
    """Holds a single agent's Ed25519 private + public key."""

    def __init__(
        self,
        private_key: Ed25519PrivateKey,
        agent_id: str = "",
    ) -> None:
        self.agent_id = agent_id
        self.private_key = private_key
        self.public_key = private_key.public_key()

    # ── Signing / Verification ─────────────────────────────────────

    def sign(self, data: bytes) -> bytes:
        """Sign *data* with this agent's private key.

        Returns the raw 64-byte Ed25519 signature.
        """
        return self.private_key.sign(data)

    def verify(self, signature: bytes, data: bytes) -> bool:
        """Verify *signature* over *data* using this key pair's public key."""
        try:
            self.public_key.verify(signature, data)
            return True
        except Exception:
            return False

    # ── Serialisation helpers ──────────────────────────────────────

    def public_key_bytes(self) -> bytes:
        """Return the public key in raw 32-byte form."""
        return self.public_key.public_bytes(
            serialization.Encoding.Raw,
            serialization.PublicFormat.Raw,
        )

    def public_key_pem(self) -> str:
        """Return the public key as a PEM string."""
        return self.public_key.public_bytes(
            serialization.Encoding.PEM,
            serialization.PublicFormat.SubjectPublicKeyInfo,
        ).decode()


class Ed25519KeyManager:
    """Registry of Ed25519 key pairs, keyed by agent ID.

    Usage::

        km = Ed25519KeyManager(keys_dir=Path("keys"))
        km.load_or_generate("builder-001", prefix="builder")

        pair = km.get("builder-001")
        sig  = pair.sign(b"hello")
        ok   = km.verify("builder-001", sig, b"hello")
    """

    def __init__(self, keys_dir: Optional[Path] = None) -> None:
        self._keys: dict[str, Ed25519KeyPair] = {}
        self._public_keys: dict[str, Ed25519PublicKey] = {}
        self.keys_dir = keys_dir or Path("keys")

    # ── Public API ─────────────────────────────────────────────────

    def load_or_generate(
        self,
        agent_id: str,
        prefix: Optional[str] = None,
    ) -> Ed25519KeyPair:
        """Load an Ed25519 key pair for *agent_id*.

        Resolution order:
        1. Environment variable ``<PREFIX>_PRIVATE_KEY`` (PEM string).
        2. PEM file at ``<keys_dir>/<prefix>_private.pem``.
        3. Auto-generate a transient in-memory key pair (dev fallback).

        Args:
            agent_id: Unique agent identifier (e.g. ``builder-001``).
            prefix: Short name used for env vars and filenames.
                Defaults to the part before the first ``-`` in *agent_id*
                (e.g. ``builder`` from ``builder-001``).

        Returns:
            The loaded (or generated) key pair, also stored internally.
        """
        if agent_id in self._keys:
            return self._keys[agent_id]

        prefix = prefix or agent_id.split("-")[0]

        # 1) Try environment variable
        env_name = f"{prefix.upper()}_PRIVATE_KEY"
        env_value = os.environ.get(env_name, "").strip()
        if env_value:
            try:
                private_key = serialization.load_pem_private_key(
                    env_value.encode(), password=None
                )
                pair = Ed25519KeyPair(private_key, agent_id)  # type: ignore[arg-type]
                self._register(agent_id, pair)
                logger.info("ed25519_key_loaded_from_env", agent_id=agent_id, env=env_name)
                return pair
            except Exception as exc:
                logger.warning(
                    "ed25519_env_key_invalid",
                    agent_id=agent_id,
                    env=env_name,
                    error=str(exc)[:200],
                )

        # 2) Try PEM file
        pem_path = self.keys_dir / f"{prefix}_private.pem"
        if pem_path.is_file():
            try:
                pem_data = pem_path.read_bytes()
                private_key = serialization.load_pem_private_key(pem_data, password=None)
                pair = Ed25519KeyPair(private_key, agent_id)  # type: ignore[arg-type]
                self._register(agent_id, pair)
                logger.info("ed25519_key_loaded_from_file", agent_id=agent_id, path=str(pem_path))
                return pair
            except Exception as exc:
                logger.warning(
                    "ed25519_file_key_invalid",
                    agent_id=agent_id,
                    path=str(pem_path),
                    error=str(exc)[:200],
                )

        # 3) Auto-generate (development fallback)
        logger.warning(
            "ed25519_key_auto_generated",
            agent_id=agent_id,
            hint="Set env var or generate keys with 'make setup' for production",
        )
        private_key = Ed25519PrivateKey.generate()
        pair = Ed25519KeyPair(private_key, agent_id)
        self._register(agent_id, pair)
        return pair

    def get(self, agent_id: str) -> Optional[Ed25519KeyPair]:
        """Return the key pair for *agent_id*, or ``None``."""
        return self._keys.get(agent_id)

    def get_public_key(self, agent_id: str) -> Optional[Ed25519PublicKey]:
        """Return the public key for *agent_id* (works even if only public key is registered)."""
        pair = self._keys.get(agent_id)
        if pair:
            return pair.public_key
        return self._public_keys.get(agent_id)

    def verify(self, agent_id: str, signature: bytes, data: bytes) -> bool:
        """Verify a signature using the public key registered for *agent_id*.

        Returns ``False`` if the agent is unknown or the signature is invalid.
        """
        pub = self.get_public_key(agent_id)
        if pub is None:
            logger.warning("ed25519_verify_unknown_agent", agent_id=agent_id)
            return False
        try:
            pub.verify(signature, data)
            return True
        except Exception:
            return False

    def register_public_key(self, agent_id: str, public_key: Ed25519PublicKey) -> None:
        """Register an external agent's public key (for verification only)."""
        self._public_keys[agent_id] = public_key

    @property
    def registered_agents(self) -> list[str]:
        """Return a list of all agent IDs with loaded key pairs."""
        return list(self._keys.keys())

    # ── Internal ───────────────────────────────────────────────────

    def _register(self, agent_id: str, pair: Ed25519KeyPair) -> None:
        self._keys[agent_id] = pair
        self._public_keys[agent_id] = pair.public_key
